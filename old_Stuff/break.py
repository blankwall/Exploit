ida = 0x74c20000
real= 0x689b0000 
bps = []
late = []

# Ctable layout = 4246628


get_layout = 0x74d1d447
'''
.text:74D1D447                 push    158h
.text:74D1D44C                 push    8
.text:74D1D44E                 push    _g_hProcessHeap //layout creation
'''
bps.append(get_layout)

add_col = 0x74fea538 
'''
.text:74FEA532                 mov     eax, [ebx+7Ch]
.text:74FEA535                 shr     eax, 2     // eax is the count of the span
.text:74FEA538                 mov     ecx, ebx  //Ctablelayout reference
.text:74FEA53A                 call    CTableLayout::EnsureCols(int) //effects span attribute
'''
bps.append(add_col)

calc_layout = 0x74D3070E
'''
.text:74D30705                 mov     [esp+210h+var_1EC], edx
.text:74D30709                 push    ebx       //Ctablelayout reference
.text:74D3070A                 mov     [esp+214h+var_1D4], eax
.text:74D3070E                 call    CalculateMinMax@CTableLayout
'''
bps.append(calc_layout)

buf_size = 0x74D302EC 
'''
.text:74D302EC                 push    1Ch
.text:74D302EE                 mov     eax, edx //span
.text:74D302F0                 mov     edi, esi //struct inside c table layout
.text:74D302F2                 call    CImplAry::EnsureSizeWorker(uint,long)
'''
bps.append(buf_size)

size_work = 0x74df8fd0
'''
.text:74DF8FD0                 mov     eax, [ebp+var_4]
.text:74DF8FD3                 mul     [ebp+arg_0] //eax = size 0xfc vuln buffer size
.text:74DF8FD6                 push    edx
.text:74DF8FD7                 push    eax
.text:74DF8FD8                 lea     eax, [ebp-8] //stores result of call
.text:74DF8FDB                 call    ULongLongToUInt(unsigned __int64,uint *)
'''
late.append(size_work)

realloc = 0x74DF8FF0       
'''
.text:74DF8FF0                 push    ebp+dwBytes]   ; 0xa8
.text:74DF8FF3                 lea     esi, [edi+0Ch]
.text:74DF8FF6                 call    ?_HeapRealloc@@YGJPAPAXI@Z ;
Vulnerable buffer will be located in esi(edi+0xc) edi = ctablelayout + 0x90 so buffer is at 0x9c
'''
late.append(realloc)

update_span = 0x74cba021
'''
.text:74EC5A2E                 call   CTableCol::GetAAspan(void)
[....]
.text:74CBA021                 pop     esi
.text:74CBA022                 leave
.text:74CBA023                 retn //eax = new span size
'''
bps.append(update_span)

buf_acc = 0x74ec5b4f
'''
ebx holds the ctable layout reference here remember previously 0x9c was called creating vuln buffer :)

.text:74EC5B4F                 mov     eax, [ebx+9Ch] /accesses buffer here
.text:74EC5B55                 add     eax, ecx
'''
bps.append(buf_acc)

buf_fill = 0x74ec5b86
'''
.text:74EC5B83                 mov     esi, [ebp+var_24]
.text:74EC5B86                 push    [ebp+var_C]
.text:74EC5B89                 call    CTableColCalc::AdjustForCol //fills buffer based off of span attribute
'''
bps.append(buf_fill)

loop = 0x74ec5b98
'''
.text:74EC5B98                 cmp     eax, [ebp+arg_8] //loop determining how many times to fill overwrite here
.text:74EC5B9B                 jl      short loc_74EC5B4C
buffer address will be located in esi
table layout will be in ebx

0:005> !heap -p -a esi
    address 02a17dd0 found in
    _HEAP @ 70000
      HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state
        02a17ce8 0021 0000  [00]   02a17cf0    000fc - (busy)

'''
bps.append(loop)


crash = 0x74de7512
'''
69c774f9 85c0            test    eax,eax
69c774fb 7426            je      mshtml!NotifyElement+0x56 (69c77523) //not taken
69c774fd 8bc7            mov     eax,edi
69c774ff e8b1faffff      call    mshtml!CElement::CurrentlyHasAnyLayout (69c76fb5)
69c77504 85c0            test    eax,eax
69c77506 0f84c321e9ff    je      mshtml!NotifyElement+0x39 (69b096cf) //not taken
69c7750c 8b4f24          mov     ecx,dword ptr [edi+24h]
69c7750f 8b01            mov     eax,dword ptr [ecx] //ecx = cbutton reference
69c77511 56              push    esi
69c77512 ff5008          call    dword ptr [eax+8]    ds:0023:07ffffec=???? eax and edx are controlled values
eax = value overwritten in cbutton 0x7ffffe4 + 8
'''
bps.append(crash)

#print "SET FIRST BP THEN WHEN HIT SET OTHERS"
for i in bps:
	x = i - ida
	print "bp {0}".format(hex(x+real))

print "DO NOT SET LAST BP TILL THE END!"
print "s -d 0 l?0x80000000 00410041"

for i in late:
	x = i - ida
#	print "bp {0}".format(hex(x+real))
