//VULN
// values are copied from an array into a second, neutered array. 
// This allows for an out-of-bounds write into memory, causing an exploitable crash leading to arbitrary code execution.
ObjectElements *
ArrayBufferObject::getTransferableContents(JSContext *maybecx, bool *callerOwns)
{
    if (hasDynamicElements() && !isAsmJSArrayBuffer()) {
        *callerOwns = false;
        return getElementsHeader();
    }

    uint32_t byteLen = byteLength();
    ObjectElements *newheader = AllocateArrayBufferContents(maybecx, byteLen, dataPointer());
    if (!newheader)
        return NULL;

    initElementsHeader(newheader, byteLen);
    *callerOwns = true;
    return newheader;
}


//does not prevent a zero-length transition during use of an ArrayBuffer object
// VULN


    static bool
    copyFromArray(JSContext *cx, HandleObject thisTypedArrayObj,
                  HandleObject ar, uint32_t len, uint32_t offset = 0)
    {
        Rooted<TypedArrayObject*> thisTypedArray(cx, &thisTypedArrayObj->as<TypedArrayObject>());
        JS_ASSERT(offset <= thisTypedArray->length());
        JS_ASSERT(len <= thisTypedArray->length() - offset);
        if (ar->is<TypedArrayObject>())
            return copyFromTypedArray(cx, thisTypedArray, ar, offset);


//PATCH

    static bool
    copyFromArray(JSContext *cx, HandleObject thisTypedArrayObj,
                  HandleObject ar, uint32_t len, uint32_t offset = 0)
    {
        // Exit early if nothing to copy, to simplify loop conditions below.
        if (len == 0)
            return true;

        Rooted<TypedArrayObject*> thisTypedArray(cx, &thisTypedArrayObj->as<TypedArrayObject>());
        JS_ASSERT(offset <= thisTypedArray->length());
        JS_ASSERT(len <= thisTypedArray->length() - offset);
        if (ar->is<TypedArrayObject>())
            return copyFromTypedArray(cx, thisTypedArray, ar, offset);
